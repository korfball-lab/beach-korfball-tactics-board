<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éì„Éº„ÉÅ„Ç≥„Éº„Éï„Éú„Éº„É´Êà¶Áï•„Éú„Éº„Éâ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        /* Toolbar */
        .toolbar {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .tool-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid #ddd;
        }

        .tool-group:last-child {
            border-right: none;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #f0f2f5;
            color: #333;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            background: #e4e6eb;
            transform: translateY(-1px);
        }

        .btn.active {
            background: #667eea;
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #e5e7eb;
            padding: 20px;
            overflow: auto;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            cursor: default;
        }

        /* Frame Controls - unused */
        .frame-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .frame-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .frame-item {
            padding: 10px;
            background: #f9fafb;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .frame-item:hover {
            background: #f3f4f6;
        }

        .frame-item.active {
            background: #ddd6fe;
            border-left: 3px solid #667eea;
        }

        .frame-delete {
            color: #ef4444;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .frame-delete:hover {
            background: #fee2e2;
        }

        /* Players Panel */
        .players-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .team-section {
            background: #f9fafb;
            padding: 12px;
            border-radius: 6px;
        }

        .team-section h4 {
            font-size: 14px;
            margin-bottom: 10px;
            text-align: center;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background: white;
            border-radius: 4px;
            font-size: 13px;
        }

        .player-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
        }

        .player-icon.circle {
            border-radius: 50%;
        }

        .player-icon.triangle {
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 20px solid;
            position: relative;
        }

        /* Color Picker */
        .color-picker {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.active {
            border-color: #333;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #333;
        }

        /* Input Groups */
        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #6b7280;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            min-height: 200px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <h1>üèê „Éì„Éº„ÉÅ„Ç≥„Éº„Éï„Éú„Éº„É´Êà¶Áï•„Éú„Éº„Éâ</h1>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <div class="tool-group">
                <button class="btn active" data-tool="select" title="ÈÅ∏Êäû„ÉªÁßªÂãï">
                    üñ±Ô∏è ÈÅ∏Êäû
                </button>
                <button class="btn" data-tool="freehand" title="„Éï„É™„Éº„Éè„É≥„ÉâÊèèÁîª">
                    ‚úèÔ∏è ÊèèÁîª
                </button>
                <button class="btn" data-tool="eraser" title="Ê∂à„Åó„Ç¥„É†">
                    üßπ Ê∂àÂéª
                </button>
            </div>

            <div class="tool-group">
                <label style="font-size: 12px; color: #666;">Á∑ö„ÅÆÂ§™„Åï:</label>
                <input type="range" id="lineWidth" min="1" max="8" value="3" style="width: 80px;">
                <span id="lineWidthValue" style="font-size: 12px; color: #666;">3</span>
            </div>

            <div class="tool-group">
                <div class="color-picker">
                    <div class="color-option active" data-color="#000000" style="background: #000000;" title="Èªí"></div>
                    <div class="color-option" data-color="#ef4444" style="background: #ef4444;" title="Ëµ§"></div>
                    <div class="color-option" data-color="#3b82f6" style="background: #3b82f6;" title="Èùí"></div>
                </div>
            </div>

            <div class="tool-group">
                <button class="btn" id="undoBtn" title="ÂÖÉ„Å´Êàª„Åô">‚Ü©Ô∏è</button>
                <button class="btn" id="redoBtn" title="„ÇÑ„ÇäÁõ¥„Åó">‚Ü™Ô∏è</button>
                <button class="btn" id="clearDrawingBtn" title="ÊèèÁîª„Çí„ÇØ„É™„Ç¢">üóëÔ∏è ÊèèÁîª</button>
                <button class="btn btn-danger" id="resetBtn" title="ÂÖ®„Å¶„É™„Çª„ÉÉ„Éà">üîÑ „É™„Çª„ÉÉ„Éà</button>
            </div>

            <div class="tool-group">
                <button class="btn btn-primary" id="saveBtn">üíæ ‰øùÂ≠ò</button>
                <button class="btn btn-primary" id="loadBtn">üìÇ Ë™≠Ëæº</button>
                <button class="btn btn-primary" id="exportBtn">üì∏ PNGÂá∫Âäõ</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Canvas Area -->
            <div class="canvas-area">
                <div class="canvas-wrapper">
                    <canvas id="beachKorfballBoard"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div class="modal" id="saveModal">
        <div class="modal-content">
            <div class="modal-header">„Éó„É¨„Ç§„Çí‰øùÂ≠ò</div>
            <div class="input-group">
                <label>„Éó„É¨„Ç§Âêç</label>
                <input type="text" id="playName" placeholder="‰æã: „Ç™„Éï„Çß„É≥„Çπ1">
            </div>
            <div class="input-group">
                <label>„Éá„Éº„ÇøÔºàËá™ÂãïÁîüÊàêÔºâ</label>
                <textarea id="saveData" readonly></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="closeSaveModal">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn btn-primary" id="copyDataBtn">„Ç≥„Éî„Éº</button>
            </div>
        </div>
    </div>

    <!-- Load Modal -->
    <div class="modal" id="loadModal">
        <div class="modal-content">
            <div class="modal-header">„Éó„É¨„Ç§„ÇíË™≠„ÅøËæº„Åø</div>
            <div class="input-group">
                <label>„Éá„Éº„Çø„ÇíË≤º„Çä‰ªò„Åë</label>
                <textarea id="loadData" placeholder="‰øùÂ≠ò„Åó„ÅüJSON„Éá„Éº„Çø„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ"></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="closeLoadModal">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn btn-primary" id="loadDataBtn">Ë™≠„ÅøËæº„Åø</button>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const COURT_WIDTH = 20; // meters
        const COURT_LENGTH = 10; // meters
        const BORDER_WIDTH = 2; // meters
        const PLAYER_RADIUS = 0.5; // meters - increased for better visibility

        // Canvas setup
        const canvas = document.getElementById('beachKorfballBoard');
        const ctx = canvas.getContext('2d');
        let scale;

        // Set initial canvas size to prevent blank screen
        canvas.width = 800;
        canvas.height = 600;

        // State
        let currentTool = 'select';
        let currentColor = '#000000';
        let currentLineWidth = 3;
        let frames = [];
        let currentFrameIndex = 0;
        let selectedObject = null;
        let isDragging = false;
        let offset = { x: 0, y: 0 };
        let drawingStart = null;
        let tempDrawing = null;
        let history = [];
        let historyIndex = -1;

        // Initialize first frame
        function createNewFrame() {
            const courtStartX = BORDER_WIDTH;
            const courtStartY = BORDER_WIDTH + 1.5; // Add vertical offset to center
            const courtWidth = COURT_WIDTH;
            const courtLength = COURT_LENGTH;

            return {
                players: [
                    // Team A - On Court (1-4)
                    {position: [courtStartX + courtWidth * 0.2, courtStartY + courtLength * 0.3], color: '#ef4444', number: '1', gender: 'boy', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.4, courtStartY + courtLength * 0.2], color: '#ef4444', number: '2', gender: 'boy', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.3, courtStartY + courtLength * 0.5], color: '#ef4444', number: '3', gender: 'girl', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.1, courtStartY + courtLength * 0.4], color: '#ef4444', number: '4', gender: 'girl', team: 'A'},
                    // Team A - Substitutes (5-8) - Top area
                    {position: [courtStartX + courtWidth * 0.1, courtStartY - 1.0], color: '#ef4444', number: '5', gender: 'boy', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.2, courtStartY - 1.0], color: '#ef4444', number: '6', gender: 'boy', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.3, courtStartY - 1.0], color: '#ef4444', number: '7', gender: 'girl', team: 'A'},
                    {position: [courtStartX + courtWidth * 0.4, courtStartY - 1.0], color: '#ef4444', number: '8', gender: 'girl', team: 'A'},
                    // Team B - On Court (9-12)
                    {position: [courtStartX + courtWidth * 0.8, courtStartY + courtLength * 0.3], color: '#3b82f6', number: '9', gender: 'boy', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.6, courtStartY + courtLength * 0.2], color: '#3b82f6', number: '10', gender: 'boy', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.7, courtStartY + courtLength * 0.5], color: '#3b82f6', number: '11', gender: 'girl', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.9, courtStartY + courtLength * 0.4], color: '#3b82f6', number: '12', gender: 'girl', team: 'B'},
                    // Team B - Substitutes (13-16) - Top area
                    {position: [courtStartX + courtWidth * 0.6, courtStartY - 1.0], color: '#3b82f6', number: '13', gender: 'boy', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.7, courtStartY - 1.0], color: '#3b82f6', number: '14', gender: 'boy', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.8, courtStartY - 1.0], color: '#3b82f6', number: '15', gender: 'girl', team: 'B'},
                    {position: [courtStartX + courtWidth * 0.9, courtStartY - 1.0], color: '#3b82f6', number: '16', gender: 'girl', team: 'B'},
                ],
                ball: { position: [courtStartX + courtWidth * 0.26, courtStartY + courtLength * 0.3], color: '#FFEB3B', radius: 0.3 },
                drawings: []
            };
        }

        frames.push(createNewFrame());

        // Resize canvas
        function resizeCanvas() {
            const totalWidth = COURT_WIDTH + 2 * BORDER_WIDTH;
            const totalHeight = COURT_LENGTH + 2 * BORDER_WIDTH + 3; // Space for top (1.5) and bottom (1.5) to center court
            const aspectRatio = totalWidth / totalHeight;

            const maxWidth = window.innerWidth - 40; // No sidebar, just padding
            const maxHeight = window.innerHeight - 150; // Space for header and toolbar

            if (maxWidth / maxHeight > aspectRatio) {
                canvas.height = maxHeight;
                canvas.width = canvas.height * aspectRatio;
            } else {
                canvas.width = maxWidth;
                canvas.height = canvas.width / aspectRatio;
            }

            scale = canvas.width / totalWidth;
            draw();
        }

        // Drawing functions
        function drawCourt() {
            const courtStartX = BORDER_WIDTH * scale;
            const courtStartY = (BORDER_WIDTH + 1.5) * scale; // Add 1.5m offset to center vertically
            const courtWidthPx = COURT_WIDTH * scale;
            const courtLengthPx = COURT_LENGTH * scale;

            // Background gradient for border area
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, '#87CEEB');
            bgGradient.addColorStop(1, '#6BB6E0');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Shadow for court
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 5;

            // Main court - sand texture effect
            const sandGradient = ctx.createRadialGradient(
                courtStartX + courtWidthPx / 2, 
                courtStartY + courtLengthPx / 2, 
                0,
                courtStartX + courtWidthPx / 2, 
                courtStartY + courtLengthPx / 2, 
                courtWidthPx / 1.5
            );
            sandGradient.addColorStop(0, '#F5DEB3');
            sandGradient.addColorStop(0.5, '#F0E68C');
            sandGradient.addColorStop(1, '#E8D77C');
            ctx.fillStyle = sandGradient;
            ctx.fillRect(courtStartX, courtStartY, courtWidthPx, courtLengthPx);

            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Outer boundary - thick white line
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 4;
            ctx.strokeRect(courtStartX, courtStartY, courtWidthPx, courtLengthPx);

            // Inner boundary - black line
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeRect(courtStartX, courtStartY, courtWidthPx, courtLengthPx);

            // 2-point virtual line (center line) - bold dashed
            ctx.setLineDash([8, 5]);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(courtStartX + courtWidthPx / 2, courtStartY);
            ctx.lineTo(courtStartX + courtWidthPx / 2, courtStartY + courtLengthPx);
            ctx.stroke();
            ctx.setLineDash([]);

            // Free shot lines (7m lines) - dashed
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(courtStartX + 7 * scale, courtStartY);
            ctx.lineTo(courtStartX + 7 * scale, courtStartY + courtLengthPx);
            ctx.moveTo(courtStartX + courtWidthPx - 7 * scale, courtStartY);
            ctx.lineTo(courtStartX + courtWidthPx - 7 * scale, courtStartY + courtLengthPx);
            ctx.stroke();
            ctx.setLineDash([]);

            // 2-point corners - bold lines
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(courtStartX, courtStartY + 3 * scale);
            ctx.lineTo(courtStartX + 3 * scale, courtStartY);
            ctx.moveTo(courtStartX + courtWidthPx, courtStartY + 3 * scale);
            ctx.lineTo(courtStartX + courtWidthPx - 3 * scale, courtStartY);
            ctx.moveTo(courtStartX, courtStartY + courtLengthPx - 3 * scale);
            ctx.lineTo(courtStartX + 3 * scale, courtStartY + courtLengthPx);
            ctx.moveTo(courtStartX + courtWidthPx, courtStartY + courtLengthPx - 3 * scale);
            ctx.lineTo(courtStartX + courtWidthPx - 3 * scale, courtStartY + courtLengthPx);
            ctx.stroke();

            // Korfs with enhanced design
            drawKorf(courtStartX + 4 * scale, courtStartY + courtLengthPx / 2);
            drawKorf(courtStartX + courtWidthPx - 4 * scale, courtStartY + courtLengthPx / 2);
        }

        function drawKorf(x, y) {
            // Simple dark yellow circle for korf (goal)
            ctx.beginPath();
            ctx.arc(x, y, 0.3 * scale, 0, 2 * Math.PI); // Same size as ball
            ctx.fillStyle = '#D4A017'; // Dark yellow/golden
            ctx.fill();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawPlayer(player) {
            const {position, color, number, gender} = player;
            const x = position[0] * scale;
            const y = position[1] * scale;
            const playerSize = PLAYER_RADIUS * scale;

            ctx.fillStyle = color;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            if (gender === 'boy') {
                // Male players: circle
                ctx.beginPath();
                ctx.arc(x, y, playerSize, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            } else {
                // Female players: square
                ctx.fillRect(x - playerSize, y - playerSize, playerSize * 2, playerSize * 2);
                ctx.strokeRect(x - playerSize, y - playerSize, playerSize * 2, playerSize * 2);
            }

            ctx.fillStyle = 'white';
            ctx.font = `bold ${playerSize * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, x, y);
        }

        function drawBall() {
            const frame = frames[currentFrameIndex];
            const x = frame.ball.position[0] * scale;
            const y = frame.ball.position[1] * scale;
            const radius = frame.ball.radius * scale;

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = frame.ball.color;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawArrow(from, to, color, lineWidth = 3) {
            const headLength = 15;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';

            // Line
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headLength * Math.cos(angle - Math.PI / 6), to.y - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(to.x - headLength * Math.cos(angle + Math.PI / 6), to.y - headLength * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawLine(from, to, color, lineWidth = 3) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }

        function drawSmoothLine(points, color, lineWidth = 3) {
            if (points.length < 2) return;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            
            if (points.length === 2) {
                ctx.moveTo(points[0].x, points[0].y);
                ctx.lineTo(points[1].x, points[1].y);
            } else {
                ctx.moveTo(points[0].x, points[0].y);
                
                // Use quadratic curves for smooth line
                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                
                // Last point
                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            }
            ctx.stroke();
        }

        function drawCircle(center, radius, color, lineWidth = 3) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawFreehand(points, color, lineWidth = 3) {
            if (points.length < 2) return;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            // Smooth the freehand line using quadratic curves
            for (let i = 1; i < points.length - 1; i++) {
                const xc = (points[i].x + points[i + 1].x) / 2;
                const yc = (points[i].y + points[i + 1].y) / 2;
                ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
            }
            
            if (points.length > 1) {
                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
            }
            ctx.stroke();
        }

        function drawDrawings() {
            const frame = frames[currentFrameIndex];
            frame.drawings.forEach(drawing => {
                const lineWidth = drawing.lineWidth || 3;
                switch (drawing.type) {
                    case 'arrow':
                        drawArrow(drawing.from, drawing.to, drawing.color, lineWidth);
                        break;
                    case 'line':
                        drawLine(drawing.from, drawing.to, drawing.color, lineWidth);
                        break;
                    case 'smoothline':
                        drawSmoothLine(drawing.points, drawing.color, lineWidth);
                        break;
                    case 'circle':
                        drawCircle(drawing.center, drawing.radius, drawing.color, lineWidth);
                        break;
                    case 'freehand':
                        drawFreehand(drawing.points, drawing.color, lineWidth);
                        break;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCourt();
            
            const frame = frames[currentFrameIndex];
            frame.players.forEach(drawPlayer);
            drawBall();
            drawDrawings();

            // Draw temp drawing
            if (tempDrawing) {
                const lineWidth = currentLineWidth;
                switch (currentTool) {
                    case 'arrow':
                        drawArrow(tempDrawing.from, tempDrawing.to, currentColor, lineWidth);
                        break;
                    case 'line':
                        drawLine(tempDrawing.from, tempDrawing.to, currentColor, lineWidth);
                        break;
                    case 'smoothline':
                        if (tempDrawing.points && tempDrawing.points.length > 0) {
                            drawSmoothLine(tempDrawing.points, currentColor, lineWidth);
                        }
                        break;
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(tempDrawing.to.x - tempDrawing.from.x, 2) +
                            Math.pow(tempDrawing.to.y - tempDrawing.from.y, 2)
                        );
                        drawCircle(tempDrawing.from, radius, currentColor, lineWidth);
                        break;
                    case 'freehand':
                        if (tempDrawing.points && tempDrawing.points.length > 0) {
                            drawFreehand(tempDrawing.points, currentColor, lineWidth);
                        }
                        break;
                }
            }
        }

        // Mouse/Touch helpers
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function isPointInPlayer(pos, player) {
            const px = player.position[0] * scale;
            const py = player.position[1] * scale;
            const touchRadius = PLAYER_RADIUS * scale;
            
            if (player.gender === 'boy') {
                // Circle for male players
                const dist = Math.sqrt(Math.pow(pos.x - px, 2) + Math.pow(pos.y - py, 2));
                return dist <= touchRadius * 1.2;
            } else {
                // Square for female players
                return (pos.x >= px - touchRadius * 1.2 && pos.x <= px + touchRadius * 1.2 &&
                        pos.y >= py - touchRadius * 1.2 && pos.y <= py + touchRadius * 1.2);
            }
        }

        function isPointInBall(pos) {
            const frame = frames[currentFrameIndex];
            const bx = frame.ball.position[0] * scale;
            const by = frame.ball.position[1] * scale;
            const br = frame.ball.radius * scale;
            const dist = Math.sqrt(Math.pow(pos.x - bx, 2) + Math.pow(pos.y - by, 2));
            return dist <= br * 1.5;
        }

        // Event handlers
        function handleDoubleClick(evt) {
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            // Check if clicked on a player
            for (const player of frame.players) {
                if (isPointInPlayer(pos, player)) {
                    const newNumber = prompt('„Éó„É¨„Ç§„É§„ÉºÁï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:', player.number);
                    if (newNumber !== null && newNumber.trim() !== '') {
                        player.number = newNumber.trim();
                        saveToHistory();
                        draw();
                    }
                    return;
                }
            }
        }

        function handleMouseDown(evt) {
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select') {
                // Check ball first
                if (isPointInBall(pos)) {
                    selectedObject = frame.ball;
                    isDragging = true;
                    offset.x = pos.x - frame.ball.position[0] * scale;
                    offset.y = pos.y - frame.ball.position[1] * scale;
                    return;
                }

                // Check players
                for (const player of frame.players) {
                    if (isPointInPlayer(pos, player)) {
                        selectedObject = player;
                        isDragging = true;
                        offset.x = pos.x - player.position[0] * scale;
                        offset.y = pos.y - player.position[1] * scale;
                        return;
                    }
                }
            } else if (currentTool === 'eraser') {
                // Eraser mode - remove drawings at click position
                const eraserRadius = 15;
                frame.drawings = frame.drawings.filter(drawing => {
                    if (drawing.type === 'freehand' || drawing.type === 'smoothline') {
                        // Check if any point is near the eraser
                        return !drawing.points.some(p => 
                            Math.sqrt(Math.pow(p.x - pos.x, 2) + Math.pow(p.y - pos.y, 2)) < eraserRadius
                        );
                    } else if (drawing.type === 'arrow' || drawing.type === 'line') {
                        // Check if line passes near the eraser
                        const dist = distanceToLine(pos, drawing.from, drawing.to);
                        return dist > eraserRadius;
                    } else if (drawing.type === 'circle') {
                        // Check if circle edge is near the eraser
                        const distToCenter = Math.sqrt(
                            Math.pow(pos.x - drawing.center.x, 2) + 
                            Math.pow(pos.y - drawing.center.y, 2)
                        );
                        return Math.abs(distToCenter - drawing.radius) > eraserRadius;
                    }
                    return true;
                });
                saveToHistory();
                draw();
            } else if (['arrow', 'line', 'circle'].includes(currentTool)) {
                drawingStart = pos;
                tempDrawing = { from: pos, to: pos };
            } else if (['freehand', 'smoothline'].includes(currentTool)) {
                drawingStart = pos;
                tempDrawing = { points: [pos] };
            }
        }

        // Helper function for line distance calculation
        function distanceToLine(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }

            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleMouseMove(evt) {
            const pos = getMousePos(evt);
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select' && isDragging && selectedObject) {
                selectedObject.position[0] = (pos.x - offset.x) / scale;
                selectedObject.position[1] = (pos.y - offset.y) / scale;
                draw();
            } else if (currentTool === 'eraser' && evt.buttons === 1) {
                // Continuous erasing while mouse is down
                const eraserRadius = 15;
                const beforeLength = frame.drawings.length;
                frame.drawings = frame.drawings.filter(drawing => {
                    if (drawing.type === 'freehand' || drawing.type === 'smoothline') {
                        return !drawing.points.some(p => 
                            Math.sqrt(Math.pow(p.x - pos.x, 2) + Math.pow(p.y - pos.y, 2)) < eraserRadius
                        );
                    } else if (drawing.type === 'arrow' || drawing.type === 'line') {
                        const dist = distanceToLine(pos, drawing.from, drawing.to);
                        return dist > eraserRadius;
                    } else if (drawing.type === 'circle') {
                        const distToCenter = Math.sqrt(
                            Math.pow(pos.x - drawing.center.x, 2) + 
                            Math.pow(pos.y - drawing.center.y, 2)
                        );
                        return Math.abs(distToCenter - drawing.radius) > eraserRadius;
                    }
                    return true;
                });
                if (beforeLength !== frame.drawings.length) {
                    draw();
                }
            } else if (tempDrawing) {
                if (['arrow', 'line', 'circle'].includes(currentTool)) {
                    tempDrawing.to = pos;
                } else if (['freehand', 'smoothline'].includes(currentTool)) {
                    // Add point with some distance threshold to avoid too many points
                    const lastPoint = tempDrawing.points[tempDrawing.points.length - 1];
                    const dist = Math.sqrt(
                        Math.pow(pos.x - lastPoint.x, 2) + 
                        Math.pow(pos.y - lastPoint.y, 2)
                    );
                    if (dist > 2) { // Only add if moved more than 2 pixels
                        tempDrawing.points.push(pos);
                    }
                }
                draw();
            }
        }

        function handleMouseUp(evt) {
            const frame = frames[currentFrameIndex];

            if (currentTool === 'select') {
                if (isDragging) {
                    saveToHistory();
                }
                isDragging = false;
                selectedObject = null;
            } else if (currentTool === 'eraser') {
                // Save history after erasing
                if (evt.type === 'mouseup') {
                    saveToHistory();
                }
            } else if (tempDrawing && drawingStart) {
                const pos = getMousePos(evt);
                
                if (currentTool === 'arrow') {
                    frame.drawings.push({
                        type: 'arrow',
                        from: drawingStart,
                        to: pos,
                        color: currentColor,
                        lineWidth: currentLineWidth
                    });
                } else if (currentTool === 'line') {
                    frame.drawings.push({
                        type: 'line',
                        from: drawingStart,
                        to: pos,
                        color: currentColor,
                        lineWidth: currentLineWidth
                    });
                } else if (currentTool === 'smoothline') {
                    if (tempDrawing.points.length > 1) {
                        frame.drawings.push({
                            type: 'smoothline',
                            points: tempDrawing.points,
                            color: currentColor,
                            lineWidth: currentLineWidth
                        });
                    }
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt(
                        Math.pow(pos.x - drawingStart.x, 2) +
                        Math.pow(pos.y - drawingStart.y, 2)
                    );
                    if (radius > 5) { // Minimum radius
                        frame.drawings.push({
                            type: 'circle',
                            center: drawingStart,
                            radius: radius,
                            color: currentColor,
                            lineWidth: currentLineWidth
                        });
                    }
                } else if (currentTool === 'freehand') {
                    if (tempDrawing.points.length > 1) {
                        frame.drawings.push({
                            type: 'freehand',
                            points: tempDrawing.points,
                            color: currentColor,
                            lineWidth: currentLineWidth
                        });
                    }
                }

                saveToHistory();
                tempDrawing = null;
                drawingStart = null;
                draw();
            }
        }

        // Tool selection
        document.querySelectorAll('[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                
                // Update cursor based on tool
                if (currentTool === 'select') {
                    canvas.style.cursor = 'default';
                } else if (currentTool === 'eraser') {
                    canvas.style.cursor = 'not-allowed';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            });
        });

        // Line width control
        const lineWidthSlider = document.getElementById('lineWidth');
        const lineWidthValue = document.getElementById('lineWidthValue');
        if (lineWidthSlider && lineWidthValue) {
            lineWidthSlider.addEventListener('input', (e) => {
                currentLineWidth = parseInt(e.target.value);
                lineWidthValue.textContent = currentLineWidth;
            });
        }

        // Color selection
        document.querySelectorAll('.color-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.color-option').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
                currentColor = opt.dataset.color;
            });
        });

        // History management
        function saveToHistory() {
            const state = JSON.parse(JSON.stringify(frames));
            history = history.slice(0, historyIndex + 1);
            history.push(state);
            historyIndex++;
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        const undoBtn = document.getElementById('undoBtn');
        if (undoBtn) {
            undoBtn.addEventListener('click', () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    frames = JSON.parse(JSON.stringify(history[historyIndex]));
                    draw();
                }
            });
        }

        const redoBtn = document.getElementById('redoBtn');
        if (redoBtn) {
            redoBtn.addEventListener('click', () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    frames = JSON.parse(JSON.stringify(history[historyIndex]));
                    draw();
                }
            });
        }

        // Clear and reset
        const clearDrawingBtn = document.getElementById('clearDrawingBtn');
        if (clearDrawingBtn) {
            clearDrawingBtn.addEventListener('click', () => {
                if (confirm('ÁèæÂú®„ÅÆ„Éï„É¨„Éº„É†„ÅÆÊèèÁîª„ÇíÂÖ®„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    frames[currentFrameIndex].drawings = [];
                    saveToHistory();
                    draw();
                }
            });
        }

        const resetBtn = document.getElementById('resetBtn');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (confirm('ÂÖ®„Å¶„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂèñ„ÇäÊ∂à„Åõ„Åæ„Åõ„Çì„ÄÇ')) {
                    frames = [createNewFrame()];
                    currentFrameIndex = 0;
                    history = [];
                    historyIndex = -1;
                    draw();
                }
            });
        }

        // Save/Load
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                const data = JSON.stringify(frames, null, 2);
                const saveDataEl = document.getElementById('saveData');
                const saveModalEl = document.getElementById('saveModal');
                if (saveDataEl) saveDataEl.value = data;
                if (saveModalEl) saveModalEl.classList.add('active');
            });
        }

        const closeSaveModal = document.getElementById('closeSaveModal');
        if (closeSaveModal) {
            closeSaveModal.addEventListener('click', () => {
                const saveModalEl = document.getElementById('saveModal');
                if (saveModalEl) saveModalEl.classList.remove('active');
            });
        }

        const copyDataBtn = document.getElementById('copyDataBtn');
        if (copyDataBtn) {
            copyDataBtn.addEventListener('click', () => {
                const textarea = document.getElementById('saveData');
                if (textarea) {
                    textarea.select();
                    document.execCommand('copy');
                    alert('„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ');
                }
            });
        }

        const loadBtn = document.getElementById('loadBtn');
        if (loadBtn) {
            loadBtn.addEventListener('click', () => {
                const loadModalEl = document.getElementById('loadModal');
                if (loadModalEl) loadModalEl.classList.add('active');
            });
        }

        const closeLoadModal = document.getElementById('closeLoadModal');
        if (closeLoadModal) {
            closeLoadModal.addEventListener('click', () => {
                const loadModalEl = document.getElementById('loadModal');
                if (loadModalEl) loadModalEl.classList.remove('active');
            });
        }

        const loadDataBtn = document.getElementById('loadDataBtn');
        if (loadDataBtn) {
            loadDataBtn.addEventListener('click', () => {
                try {
                    const loadDataEl = document.getElementById('loadData');
                    if (!loadDataEl) return;
                    
                    const data = loadDataEl.value;
                    const loadedFrames = JSON.parse(data);
                    frames = loadedFrames;
                    currentFrameIndex = 0;
                    history = [];
                    historyIndex = -1;
                    draw();
                    
                    const loadModalEl = document.getElementById('loadModal');
                    if (loadModalEl) loadModalEl.classList.remove('active');
                    loadDataEl.value = '';
                    alert('„Éó„É¨„Ç§„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ');
                } catch (e) {
                    alert('„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊ≠£„Åó„ÅÑJSONÂΩ¢Âºè„ÅãÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                }
            });
        }

        // Export
        const exportBtn = document.getElementById('exportBtn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `korfball-play-${Date.now()}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        // Event listeners
        canvas.addEventListener('dblclick', handleDoubleClick);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseDown(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handleMouseMove(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleMouseUp(e);
        });

        // Initialize
        window.addEventListener('resize', resizeCanvas);
        canvas.style.cursor = 'default'; // Set initial cursor for select tool
        resizeCanvas();
        saveToHistory();
    </script>
</body>
</html>
